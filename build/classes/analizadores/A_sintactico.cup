
package analizadores;

import java_cup.runtime.Symbol;
import arbol.Imprimir;
import java.util.LinkedList;
import arbol.Nodo;

parser code 
{:
        public static Nodo raiz;
        
        public Nodo getRaiz(){
            return raiz;
        }
        

        public void syntax_error(Symbol s)
        {
            System.err.println("Error en la Linea " + (s.right+1) +" Columna "+(s.left+1)+ ". Identificador "+s.value + " no reconocido. Se ha recuperado del error." );
        }

        public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception
        {
            System.err.println("Error en la Linea " + (s.right+1)+ " Columna "+(s.left+1)+". Identificador " +s.value + " no reconocido.");
        }
:}

terminal String IDENTIFICADOR, ENTERO,CARACTER,DECIMAL,res_VERDADERO,res_FALSO, BLANCOS;
terminal String res_INICIO, res_FIN,res_SI,res_COMO,res_ELSEIF,res_PARA,res_SEGUN;
terminal String res_HACER, res_HASTA, res_NUMERO, res_FINSI,res_METODO,res_REPETIR;
terminal String res_FINPARA,res_INGRESAR,res_IMPRIMIR,res_CARACTER,res_RETORNAR,res_ENTONCES;
terminal String res_EJECUTAR,res_MIENTRAS,res_FINSEGUN,res_CONVALOR,res_HASTAQ,res_FINMETODO;
terminal String res_FINFUNCION,res_IMPRIMIRNL,res_FINMIENTRAS,res_FUNCION,res_CONINCREM;
terminal String res_ELSE,res_METODOCONP,res_CADENA,res_BOOLEAN,res_POTENCIA,res_MOD;
terminal String res_MAYOR,res_MENOR,res_MENORIGUAL,res_MAYORIGUAL,res_ESIGUAL,res_ESDIFERENTE,res_OR,res_AND,res_NOT;

terminal String tk_MAS,tk_DIVIDIDO,tk_POR,tk_PTCOMA,tk_COMA,tk_LLAVIZQ,tk_LLAVDER ;
terminal String tk_PARIZQ, tk_PARDER, tk_MENOS, tk_CONCAT,tk_MENQUE,tk_MAYQUE, tk_IGUAL;
terminal String tk_CADENA,tk_INCREMENTO,tk_DECREMENTO,tk_ASIGNAFLECHA;

non terminal Nodo INICIO,I,RECURSIVE,BEGIN,DECLARA,ASIGNA,CONDICION,SWITCH,FOR,WHILE,HASTA,METODO,FUNCION,PRINT;
non terminal Nodo LISTID,TIPO,INSTRUCCIONES,EXPRESION_NUM,EXPRESION_logica,EXPRESION_relacional,EXPRESION_cadena;
non terminal Nodo RECURSIVE_INST,ELSEIF,LISTP,EJECUTAR;

precedence left tk_MAS,tk_MENOS,tk_POR,tk_DIVIDIDO,res_MOD,res_POTENCIA ;

start with INICIO;

INICIO::= I:a {: parser.raiz = a; :} //Raiz del AST

//INICIO::=  RECURSIVE:a{:parser.raiz = a;:} //Raiz del AST
;
// INICIO::= DECLARA ;//TESTS

I::=res_INICIO:a RECURSIVE:b res_FIN:c{: Nodo padre = new Nodo("INICIO", "", 0,0);             //creamos un nodo padre identificandolo con el nombre del no terminal del lado izq de la produccion
                                         padre.AddHijo(new Nodo("res_Inicio", "", 0,0)); 
                                         padre.AddHijo(b);
                                         padre.AddHijo(new Nodo("res_FIN", "", 0,0)); 
                                         RESULT = padre; :}
;

RECURSIVE::=  RECURSIVE:a BEGIN:b {: Nodo padre = new Nodo("INSTRUCCIONES", "", 0,0);             //creamos un nodo padre identificandolo con el nombre del no terminal del lado izq de la produccion
                                     padre.AddHijo(a); 
                                     padre.AddHijo(b);
                                     RESULT = padre; :}
                | BEGIN:a         {: Nodo padre = new Nodo("INSTRUCCIONES", "", 0,0);             //creamos un nodo padre identificandolo con el nombre del no terminal del lado izq de la produccion
                                  padre.AddHijo(a); 
                                  RESULT = padre; :}
;

BEGIN::= DECLARA:a {: RESULT=a; :}
       | ASIGNA
       | CONDICION
       | SWITCH
       | FOR
       | WHILE
       | HASTA
       | METODO
       | FUNCION
       | PRINT:a {: RESULT=a; :}// retornamos el nodo que viene ya creado de declaracion
       | error
;

DECLARA::= res_INGRESAR:a LISTID:b res_COMO:c TIPO:d res_CONVALOR:e EXPRESION_NUM:f tk_PTCOMA:g {:
                                                                            Nodo padre = new Nodo("DECLARACION", "", 0,0);
                                                                            padre.AddHijo(new Nodo("res_INGRESAR", a, aright, aleft));               //agregamos como hijo la palabra reservada imprimir
                                                                            padre.AddHijo(b);                                                        //agregamos como hijo el identificador de la cadena
                                                                            padre.AddHijo(new Nodo("res_COMO", c, cright, cleft));             //agregamos como hijo el signo ptcoma
                                                                            padre.AddHijo(d);                                                        //agregamos como hijo el identificador de la cadena
                                                                            padre.AddHijo(new Nodo("res_CVALOR", e, cright, cleft));             //agregamos como hijo el signo ptcoma
                                                                            padre.AddHijo(f);                                                        //agregamos como hijo el identificador de la cadena
                                                                            padre.AddHijo(new Nodo("tk_PTCOMA", g, cright, cleft));             //agregamos como hijo el signo ptcoma
                                                                            RESULT = padre;                                                                             
                                                                                    :}
;

ASIGNA::= LISTID tk_ASIGNAFLECHA EXPRESION_NUM tk_PTCOMA 
;

//---->CONDICIONES<----//
CONDICION::= res_SI EXPRESION_logica res_ENTONCES RECURSIVE_INST res_FINSI
           | res_SI EXPRESION_logica res_ENTONCES RECURSIVE_INST res_ELSE RECURSIVE_INST res_FINSI
           | res_SI EXPRESION_logica res_ENTONCES RECURSIVE_INST ELSEIF res_FINSI
           | res_SI EXPRESION_logica res_ENTONCES RECURSIVE_INST ELSEIF res_ELSE RECURSIVE_INST res_FINSI

;
ELSEIF::= ELSEIF res_ELSEIF  EXPRESION_logica res_ENTONCES RECURSIVE_INST
        | res_ELSEIF  EXPRESION_logica res_ENTONCES RECURSIVE_INST

;

//---->CICLOS<----//

FOR::= res_PARA LISTID tk_ASIGNAFLECHA EXPRESION_NUM res_HASTA EXPRESION_NUM res_HACER RECURSIVE_INST res_FINPARA
     //***PENDIENTE | res_PARA ASIGNA res_HASTA EXPRESION_NUM res_CONVALOR* RECURSIVE_INST res_FINPARA
;
//ESTA PENDIENTE WHUILEEEEEEE******
WHILE::= res_MIENTRAS EXPRESION_logica res_HACER RECURSIVE_INST res_FINMIENTRAS
;
HASTA::= res_REPETIR  RECURSIVE_INST res_HASTAQ EXPRESION_logica
;

//---------Switch queda pendiente xd

//--->METODOS<---//
METODO::= res_METODO IDENTIFICADOR RECURSIVE_INST res_FINMETODO
        | res_METODO IDENTIFICADOR res_METODOCONP tk_PARIZQ LISTP tk_PARDER RECURSIVE_INST res_FINMETODO
;

//--->FUNCION<---//
FUNCION::= res_FUNCION IDENTIFICADOR TIPO RECURSIVE_INST res_FINFUNCION
        | res_FUNCION IDENTIFICADOR TIPO res_METODOCONP tk_PARIZQ LISTP tk_PARDER RECURSIVE_INST res_FINFUNCION
;

//--->EJECUTAR<---//
EJECUTAR::= res_EJECUTAR IDENTIFICADOR tk_PARIZQ tk_PARDER tk_PTCOMA
          | res_EJECUTAR IDENTIFICADOR tk_PARIZQ LISTP tk_PARDER tk_PTCOMA
;

//--->PRINT<---//
PRINT::= res_IMPRIMIR:a  tk_CADENA:b tk_PTCOMA:c {: 
                                                        Nodo padre = new Nodo("PRINT", "", 0,0);
                                                        padre.AddHijo(new Nodo("res_PRINT", a, aright, aleft));               //agregamos como hijo la palabra reservada imprimir
                                                        padre.AddHijo(new Nodo("tk_cadena", b, bright, bleft));     //agregamos como hijo el identificador de la cadena
                                                        padre.AddHijo(new Nodo("tk_PTCOMA", c, cright, cleft));             //agregamos como hijo el signo ptcoma
                                                        RESULT = padre;    
                                                    :}
       | res_IMPRIMIRNL:a  tk_CADENA:b tk_PTCOMA:c {: 
                                                        Nodo padre = new Nodo("PRINTLN", "", 0,0);
                                                        padre.AddHijo(new Nodo("res_PRINTNL", a, aright, aleft));               
                                                        padre.AddHijo(new Nodo("tk_cadena", b, bright, bleft));     
                                                        padre.AddHijo(new Nodo("tk_PTCOMA", c, cright, cleft));             
                                                        RESULT = padre;    
                                                    :}
;

//-----------------------------------------------------------------//
//------------------------[Utilidades]-----------------------------//
//-----------------------------------------------------------------//

TIPO::= res_CADENA:a {: Nodo padre = new Nodo("TIPO", "", 0,0);             //creamos un nodo padre identificandolo con el nombre del no terminal del lado izq de la produccion
                       padre.AddHijo(new Nodo("res_CADENA", "", aright, aleft));
                        RESULT=padre; :}
      | res_NUMERO:a {: Nodo padre = new Nodo("TIPO", "", 0,0);             //creamos un nodo padre identificandolo con el nombre del no terminal del lado izq de la produccion
                       padre.AddHijo(new Nodo("res_num", "", aright, aleft));
                        RESULT=padre; :}
      | res_BOOLEAN:a {: Nodo padre = new Nodo("TIPO", "", 0,0);             //creamos un nodo padre identificandolo con el nombre del no terminal del lado izq de la produccion
                       padre.AddHijo(new Nodo("res_bool", a, aright, aleft));
                        RESULT=padre; :}
;

LISTID::= LISTID:a tk_COMA:b IDENTIFICADOR:c {:
                                     Nodo padre = new Nodo("LISTID", "", 0,0);             //creamos un nodo padre identificandolo con el nombre del no terminal del lado izq de la produccion
                                     padre.AddHijo(a); 
                                     padre.AddHijo (new Nodo("tk_PTCOMA", b, 0,0));
                                     padre.AddHijo (new Nodo("id", c, 0,0));
                                     RESULT = padre;
                                        :}
        | IDENTIFICADOR:a {:
                                     Nodo padre = new Nodo("LISTID", "", 0,0);             //creamos un nodo padre identificandolo con el nombre del no terminal del lado izq de la produccion
                                     padre.AddHijo (new Nodo("ID", a, 0,0));
                                     RESULT = padre;
                            :}
;
LISTP::= LISTP tk_COMA IDENTIFICADOR TIPO
        | IDENTIFICADOR TIPO
;

EXPRESION_NUM ::= EXPRESION_NUM:a tk_MAS:b EXPRESION_NUM:c {: Nodo padre = new Nodo("E", "", 0,0);                   //creamos un nodo padre identificandolo con el nombre del no terminal del lado izq de la produccion 
                                                            padre.AddHijo(a);                                       //agregamos como hijo el nodo que retorno la expresion
                                                            padre.AddHijo(new Nodo("mas", b, bright, bleft));       //agregamos como hijo el signo mas
                                                            padre.AddHijo(c);                                       //agregamos como hijo el nodo que retorno la expresion
                                                            RESULT = padre;                                         //retornamos el nodo padre
                                                            :}                              // {:objeto.call(a,b); :}
            | EXPRESION_NUM:a tk_MENOS:b EXPRESION_NUM:c{: Nodo padre = new Nodo("E", "", 0,0);                   //creamos un nodo padre identificandolo con el nombre del no terminal del lado izq de la produccion 
                                                            padre.AddHijo(a);                                       //agregamos como hijo el nodo que retorno la expresion
                                                            padre.AddHijo(new Nodo("menos", b, bright, bleft));       //agregamos como hijo el signo mas
                                                            padre.AddHijo(c);                                       //agregamos como hijo el nodo que retorno la expresion
                                                            RESULT = padre;                                         //retornamos el nodo padre
                                                            :}
            | EXPRESION_NUM:a tk_POR:b EXPRESION_NUM:c{: Nodo padre = new Nodo("E", "", 0,0);                   //creamos un nodo padre identificandolo con el nombre del no terminal del lado izq de la produccion 
                                                            padre.AddHijo(a);                                       //agregamos como hijo el nodo que retorno la expresion
                                                            padre.AddHijo(new Nodo("por", b, bright, bleft));       //agregamos como hijo el signo mas
                                                            padre.AddHijo(c);                                       //agregamos como hijo el nodo que retorno la expresion
                                                            RESULT = padre;                                         //retornamos el nodo padre
                                                            :}
            | EXPRESION_NUM:a tk_DIVIDIDO:b EXPRESION_NUM:c{: Nodo padre = new Nodo("E", "", 0,0);                   //creamos un nodo padre identificandolo con el nombre del no terminal del lado izq de la produccion 
                                                            padre.AddHijo(a);                                       //agregamos como hijo el nodo que retorno la expresion
                                                            padre.AddHijo(new Nodo("div", b, bright, bleft));       //agregamos como hijo el signo mas
                                                            padre.AddHijo(c);                                       //agregamos como hijo el nodo que retorno la expresion
                                                            RESULT = padre;                                         //retornamos el nodo padre
                                                            :}
            | EXPRESION_NUM:a res_POTENCIA:b EXPRESION_NUM:c{: Nodo padre = new Nodo("E", "", 0,0);                   //creamos un nodo padre identificandolo con el nombre del no terminal del lado izq de la produccion 
                                                            padre.AddHijo(a);                                       //agregamos como hijo el nodo que retorno la expresion
                                                            padre.AddHijo(new Nodo("pow", b, bright, bleft));       //agregamos como hijo el signo mas
                                                            padre.AddHijo(c);                                       //agregamos como hijo el nodo que retorno la expresion
                                                            RESULT = padre;                                         //retornamos el nodo padre
                                                            :}
            | EXPRESION_NUM:a res_MOD:b EXPRESION_NUM:c{: Nodo padre = new Nodo("E", "", 0,0);                   //creamos un nodo padre identificandolo con el nombre del no terminal del lado izq de la produccion 
                                                            padre.AddHijo(a);                                       //agregamos como hijo el nodo que retorno la expresion
                                                            padre.AddHijo(new Nodo("mod", b, bright, bleft));       //agregamos como hijo el signo mas
                                                            padre.AddHijo(c);                                       //agregamos como hijo el nodo que retorno la expresion
                                                            RESULT = padre;                                         //retornamos el nodo padre
                                                            :}
            | tk_PARIZQ:a EXPRESION_NUM:b tk_PARDER:c {: Nodo padre = new Nodo("E", "", 0,0); 
                                                         padre.AddHijo(new Nodo("tk_PABRE", a, aright, aleft));    
                                                         padre.AddHijo(b);    
                                                         padre.AddHijo(new Nodo("tk_PCIERRA", c, cright, cleft));    
                                                         RESULT = padre;                                         
                                                       :}
            | ENTERO:a  {: Nodo padre = new Nodo("E", "", 0,0); 
                        padre.AddHijo(new Nodo("ENTERO", a, aright, aleft));    
                        RESULT = padre;                                         
                        :}
            | DECIMAL:a {: Nodo padre = new Nodo("E", "", 0,0); 
                        padre.AddHijo(new Nodo("DECIMAL", a, aright, aleft));    
                        RESULT = padre;                                         
                        :}  
            | IDENTIFICADOR:a{: Nodo padre = new Nodo("E", "", 0,0); 
                        padre.AddHijo(new Nodo("ID", a, aright, aleft));    
                        RESULT = padre;                                         
                        :}  
            | tk_CADENA:a{: Nodo padre = new Nodo("E", "", 0,0); 
                        padre.AddHijo(new Nodo("tk_cadena", a, aright, aleft));    
                        RESULT = padre;                                         
                        :}  
            | res_VERDADERO:a{: Nodo padre = new Nodo("E", "", 0,0); 
                        padre.AddHijo(new Nodo("TRUE", a, aright, aleft));    
                        RESULT = padre;                                         
                        :}  
            | res_FALSO:a{: Nodo padre = new Nodo("E", "", 0,0); 
                        padre.AddHijo(new Nodo("FALSE", a, aright, aleft));    
                        RESULT = padre;                                         
                        :}  
;
RECURSIVE_INST::= INSTRUCCIONES RECURSIVE_INST
              | INSTRUCCIONES
;
INSTRUCCIONES::= DECLARA
               | ASIGNA
               | CONDICION
               | SWITCH
               | FOR
               | WHILE
               | HASTA
               | PRINT
;

EXPRESION_logica::= EXPRESION_NUM res_MAYOR EXPRESION_NUM
                  | EXPRESION_NUM res_MENOR EXPRESION_NUM
                  | EXPRESION_NUM res_MENORIGUAL EXPRESION_NUM
                  | EXPRESION_NUM res_MAYORIGUAL EXPRESION_NUM
                  | EXPRESION_NUM res_ESIGUAL EXPRESION_NUM
                  | EXPRESION_NUM res_ESDIFERENTE EXPRESION_NUM
                  | EXPRESION_NUM res_AND EXPRESION_NUM
                  | EXPRESION_NUM res_OR EXPRESION_NUM
                  | EXPRESION_NUM res_NOT EXPRESION_NUM  

;






















