package analizadores;
import java_cup.runtime.Symbol;
import arbol.Imprimir;

parser code 
{:

    Imprimir objeto = new Imprimir();

    //Guardar Expresiones num
    public static void CALL(){
        Imprimir objeto = new Imprimir();
}
    public static void token(Object s){ 
            //System.out.println(" Línea " + (s.left) +" Columna "+s.right); 
            System.out.println(s); 
    } 
    

    //ESte es para llamar
    public static void print(Object s){
        String newOne = s.toString();
        System.out.println("print(\""+newOne+"\")");
        
    }
    /**
     * Método al que se llama automáticamente ante algún error sintactico.
     **/ 
    public void syntax_error(Symbol s){ 
            System.err.println("Error Sintáctico en la Línea " + (s.left) +" Columna "+s.right+ ". No se esperaba este componente: " +s.value+"."); 
    } 
    /**
     * Método al que se llama en el momento en que ya no es posible una recuperación de errores.
     **/ 
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{ 
            System.err.println("Error síntactico irrecuperable en la Línea " + (s.left)+ " Columna "+s.right+". Componente " + s.value + " no reconocido."); 
    }  
:}

terminal String IDENTIFICADOR, ENTERO,CARACTER,DECIMAL,res_VERDADERO,res_FALSO, BLANCOS;
terminal String res_INICIO, res_FIN,res_SI,res_COMO,res_ELSEIF,res_PARA,res_SEGUN;
terminal String res_HACER, res_HASTA, res_NUMERO, res_FINSI,res_METODO,res_REPETIR;
terminal String res_FINPARA,res_INGRESAR,res_IMPRIMIR,res_CARACTER,res_RETORNAR,res_ENTONCES;
terminal String res_EJECUTAR,res_MIENTRAS,res_FINSEGUN,res_CONVALOR,res_HASTAQ,res_FINMETODO;
terminal String res_FINFUNCION,res_IMPRIMIRNL,res_FINMIENTRAS,res_FUNCION,res_CONINCREM;
terminal String res_ELSE,res_METODOCONP,res_CADENA,res_BOOLEAN,res_POTENCIA,res_MOD;
terminal Sring res_MAYOR,res_MENOR,res_MENORIGUAL,res_MAYORIGUAL,res_ESIGUAL,res_ESDIFERENTE,res_OR,res_AND,res_NOT;

terminal String tk_MAS,tk_DIVIDIDO,tk_POR,tk_PTCOMA,tk_COMA,tk_LLAVIZQ,tk_LLAVDER ;
terminal String tk_PARIZQ, tk_PARDER, tk_MENOS, tk_CONCAT,tk_MENQUE,tk_MAYQUE, tk_IGUAL;
terminal String tk_CADENA,tk_INCREMENTO,tk_DECREMENTO,tk_ASIGNAFLECHA;

non terminal INICIO,RECURSIVE,BEGIN,DECLARA,ASIGNA,CONDICION,SWITCH,FOR,WHILE,HASTA,METODO,FUNCION,PRINT;
non terminal LISTID,TIPO,INSTRUCCIONES,EXPRESION_NUM,EXPRESION_logica,EXPRESION_relacional,EXPRESION_cadena;
non terminal RECURSIVE_INST,ELSEIF,LISTP,EJECUTAR;

precedence left tk_MAS,tk_MENOS,tk_POR,tk_DIVIDIDO,res_MOD,res_POTENCIA ;

start with INICIO;

//INICIO::= res_INICIO RECURSIVE res_FIN;
INICIO::= HASTA ;

RECURSIVE::= BEGIN RECURSIVE
           | BEGIN
;

BEGIN::= DECLARA
       | ASIGNA
       | CONDICION
       | SWITCH
       | FOR
       | WHILE
       | HASTA
       | METODO
       | FUNCION
       | PRINT
       | error
;

DECLARA::= res_INGRESAR LISTID res_COMO TIPO res_CONVALOR EXPRESION_NUM tk_PTCOMA //{: objeto.call(a); :}
;

ASIGNA::= LISTID tk_ASIGNAFLECHA EXPRESION_NUM tk_PTCOMA 
;

//---->CONDICIONES<----//
CONDICION::= res_SI EXPRESION_logica res_ENTONCES RECURSIVE_INST res_FINSI
           | res_SI EXPRESION_logica res_ENTONCES RECURSIVE_INST res_ELSE RECURSIVE_INST res_FINSI
           | res_SI EXPRESION_logica res_ENTONCES RECURSIVE_INST ELSEIF res_FINSI
           | res_SI EXPRESION_logica res_ENTONCES RECURSIVE_INST ELSEIF res_ELSE RECURSIVE_INST res_FINSI

;
ELSEIF::= ELSEIF res_ELSEIF  EXPRESION_logica res_ENTONCES RECURSIVE_INST
        | res_ELSEIF  EXPRESION_logica res_ENTONCES RECURSIVE_INST

;

//---->CICLOS<----//

FOR::= res_PARA LISTID tk_ASIGNAFLECHA EXPRESION_NUM res_HASTA EXPRESION_NUM res_HACER RECURSIVE_INST res_FINPARA
     //***PENDIENTE | res_PARA ASIGNA res_HASTA EXPRESION_NUM res_CONVALOR* RECURSIVE_INST res_FINPARA
;
//ESTA PENDIENTE WHUILEEEEEEE******
WHILE::= res_MIENTRAS EXPRESION_logica res_HACER RECURSIVE_INST res_FINMIENTRAS
;
HASTA::= res_REPETIR  RECURSIVE_INST res_HASTAQ EXPRESION_logica
;

//---------Switch queda pendiente xd

//--->METODOS<---//
METODO::= res_METODO IDENTIFICADOR RECURSIVE_INST res_FINMETODO
        | res_METODO IDENTIFICADOR res_METODOCONP tk_PARIZQ LISTP tk_PARDER RECURSIVE_INST res_FINMETODO
;

//--->FUNCION<---//
FUNCION::= res_FUNCION IDENTIFICADOR TIPO RECURSIVE_INST res_FINFUNCION
        | res_METODO IDENTIFICADOR res_METODOCONP tk_PARIZQ LISTP tk_PARDER RECURSIVE_INST res_FINFUNCION
;

//--->EJECUTAR<---//
EJECUTAR::= res_EJECUTAR IDENTIFICADOR tk_PARIZQ tk_PARDER tk_PTCOMA
          | res_EJECUTAR IDENTIFICADOR tk_PARIZQ LISTP tk_PARDER tk_PTCOMA
;

//--->PRINT<---//
PRINT::= res_IMPRIMIR  tk_CADENA:a tk_PTCOMA{: print(a); :}
       | res_IMPRIMIRNL  tk_CADENA:a tk_PTCOMA {: print(a); :}
;

//              ---------[Utilidades]--------           //
TIPO::= res_CADENA
      | res_NUMERO
      | res_BOOLEAN
;

LISTID::= LISTID tk_COMA IDENTIFICADOR
        | IDENTIFICADOR
;
LISTP::= LISTP tk_COMA IDENTIFICADOR TIPO
        | IDENTIFICADOR TIPO
;

EXPRESION_NUM ::= EXPRESION_NUM:a tk_MAS EXPRESION_NUM:b// {:objeto.call(a,b); :}
            | EXPRESION_NUM tk_MENOS EXPRESION_NUM
            | EXPRESION_NUM tk_POR EXPRESION_NUM
            | EXPRESION_NUM tk_DIVIDIDO EXPRESION_NUM
            | EXPRESION_NUM res_POTENCIA EXPRESION_NUM
            | EXPRESION_NUM res_MOD EXPRESION_NUM
            | tk_PARIZQ EXPRESION_NUM tk_PARDER 
            | ENTERO:a //{:RESULT=a; token(RESULT); :}
            | DECIMAL
            | IDENTIFICADOR
            | tk_CADENA
            | res_VERDADERO
            | res_FALSO
;
RECURSIVE_INST::= INSTRUCCIONES RECURSIVE_INST
              | INSTRUCCIONES
;
INSTRUCCIONES::= DECLARA
               | ASIGNA
               | CONDICION
               | SWITCH
               | FOR
               | WHILE
               | HASTA
               | PRINT
;

EXPRESION_logica::= EXPRESION_NUM res_MAYOR EXPRESION_NUM
                  | EXPRESION_NUM res_MENOR EXPRESION_NUM
                  | EXPRESION_NUM res_MENORIGUAL EXPRESION_NUM
                  | EXPRESION_NUM res_MAYORIGUAL EXPRESION_NUM
                  | EXPRESION_NUM res_ESIGUAL EXPRESION_NUM
                  | EXPRESION_NUM res_ESDIFERENTE EXPRESION_NUM
                  | EXPRESION_NUM res_AND EXPRESION_NUM
                  | EXPRESION_NUM res_OR EXPRESION_NUM
                  | EXPRESION_NUM res_NOT EXPRESION_NUM  

;






















